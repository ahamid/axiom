* Only allow join/product/set operations to be performed on all
  unordered relations, or all ordered.  No mixing and matching.
  * This is because the results will be non-deterministic, and when
    order is specified, you are asserting the ordering results should
    be deterministic.
  * If an ordered relationship is joined with an unordered relationship,
    you will then only be ordering on some of the header, and not all,
    so the results will not be consistent.

* Add #optimize method to each Relation subclass
  * Relation#optimize should just return self
  * See if "attr = ? OR attr = ?" can be optimized to "attr IN(..)"
  * If an OR branch always returns true, then the whole operation
    returns true, so return an object that represents a true match.
  * If the Restriction ends up containing only a single "true"
    object, then it should factor itself out since it can match
    everything.
  * For Equality, if left and right are constants, evaluate the predicate
    and return the true/false value.
  * For Equality, if left and right are the same attribute, return true
  * After optimizing a relation, set @optimized to whatever the return
    value is, and use @optimized ||= in #optimize to prevent duplicate
    effort.
  * In the optimized relation, use "relation.optimized = self" to prevent
    an already optimized relation from performing any redundant
    optimizations.
  * Should optimize the "contained" Relation objects first, and then
    compare them:

      def optimize
        relation = relation.optimize
        case relation
          when Join
            # ...
        end
      end

* Refactor common code from Offset and Limit
  - Use Flay to identify duplicate code and refactor

* Look at optimizing the Tuple as a Struct

* Add Relation#antijoin

* Add Relation#nest and Relation#unnest
