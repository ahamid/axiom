* Add #optimize method to each Relation subclass
  * If two relations have the same restrictions, order, limit, offset,
    header and base, then Union#optimize and Intersection#optimize should
    just return one of them.
  * If two relations have the same restrictions, order, limit, offset,
    header and base, then Difference#optimize should return an empty
    Relation.
  * See if "attr = ? OR attr = ?" can be optimized to "attr IN(..)"
  * A Reverse that contains a Reverse should factor itself out.
  * A Limit that contains a Limit, should return a Limit object
    using the smallest limit of the two.
  * An Offset that contains an Offset should return an Offset object
    that adds the offsets together.
  * An Order that contains an Order should return the outer-most
    Order.

* In Predicate, Proposition and Connective #==, make sure that it
  works by comparing equivalent operations.  eg :id >= 1 is the
  same as not(id < 1), and should return true

* Instead of True.new and False.new, just use the constants in the code
  * Make sure that all the instance methods are changed to be class methods

* Use Flay to identify duplicate code and refactor

* Add Relation#antijoin

* Add Relation#nest and Relation#unnest
