* Add return types to Function objects
  * Update Evaluator::Context to infer the type from the function if
    possible, only defaulting to Attribute::Object if the type is unknown.

* Raise an exception if trying to summarize on an attribute that isn't projected
  away. For example it makes no sense to sum price when it's still present
  in the header.
  * Also make sure summarize_by is a subset of the original header, raise an
    exception if it is not a proper subset.

* Remove Order, Reverse, Limit and Offset from the Relation inheritance chain
  * Instead make it so they are proxy classes that wrap Relations, but
    proxy method calls to the Relation methods, and then wrap the return
    value (assuming it's a Relation) in a copy of itself.
  * Also this will allow knowledge of #directions to be removed from
    all the Relation classes. Only the Ranking classes will need to know
    about directions.
  * We can also do things like optimize away an Order that is not
    wrapped by a Limit/Offset if it is wrapped in Join or Set relation.
    We can do this because joining sorted relations results in
    an undefined sort order depending on the algorithm used to join
    the tuples. The correct approach to get unambiguous results is to
    wrap the Join in an Order.
  * The Reverse class will probably not be needed either. All we need is
    for the #reverse method to create a new Order with the directions
    reversed.
  * Remove the knowledge of directions from materialized relations
    and instead wrap materialized relations in the Order object
    if any.

* Allow Inclusion match to accept a Relation
  * Ensure that Inclusion can have the left/right be an Array of
    Attributes.
  * Consider transforming the value provided to an Inclusion into
    a Relation.

* Update Attributes so that constraints are modelled using predicates,
  so that when "join-ability" is tested, the predicates can just be
  compared for equality.
  * Create an object that can wrap a predicate, and if it fails it will
    set the object's error state, and then propagate the status to the
    caller. This will allow a "complex" predicate to set the errors
    on tuples, while still allowing all the same objects to be used.

* Add Relation#antijoin

* Add Relation#nest and Relation#unnest

* Add aliases for some common operations in Method classes, eg:
  * Predicates:
    * Alias #== to #eq (may break alot)
    * Alias #!= to #ne (in 1.9 only)
    * Alias #>= to #gte
    * Alias #> to #gt
    * Alias #<= to #lte
    * Alias #< to #lt
    * Alias #=~ to #match
  * Direction:
    * Alias #@+ to #asc
    * Alias #@- to #desc

* Update memoization to take into account the arguments passed into
  the method. It should memoize differently for different
  methods. Perhaps it could have a special case for methods
  with a 0-arity vs n-arity methods, but it needs to handle cases
  like with #hash that accept no args, and #optimize that accepts
  1 arg.
