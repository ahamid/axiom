* Add aliases for some common operations in Method classes, eg:
  * Predicates:
    * Alias #== to #eq (may break alot)
    * Alias #!= to #ne (in 1.9 only)
    * Alias #>= to #gte
    * Alias #> to #gt
    * Alias #<= to #lte
    * Alias #< to #lt
    * Alias #=~ to #match
  * Direction:
    * Alias #@+ to #asc
    * Alias #@- to #desc

* Use flay to identify duplicate code and refactor

* Consider adding a complement class to each predicate (and other ops)

* Extract optimization into Optimizer class
  * Make sure it can be inherited and optimization overridden on a
    per-operation basis.
  * Think about the design. Will it be some sort of Factory that
    returns an object that knows how to optimize instances of a
    specific class? Will it be a map? Will different optimizers be
    needed for each adapter (YES)? Will an optimizer alter their
    approach over time? Will it take into account cases where the
    data is already known, to alter other queries (eg. if a join between
    in-memory and an RDBMS, use the in-memory values in an IN() clause)
  * Consider what it would take to expose the Optimizer to the end user
    who wants to control how optimization is performed for their
    adapter and/or add something into the chain that will take
    precedence over both the per-adapter optimizer, and the base
    optimizer. Even just making it so that the Factory object is
    returned from a method that can be easily overridden might make
    it much nicer for the end user.

* Add further optimizations:
  * Operation Order:
    * Projection should follow Rename
      * When a Projection contains a Restriction, wrap the Projection
        in the Restriction, projecting away any attributes not used in
        the restriction. If there are any remaining attributes, then
        wrap the operation in a Projection removing those attributes.
        * If all attributes are being used in the Restriction do nothing
      * When a Projection contains a Join, wrap the Join with a Projection
        of all the headers, minus those used in the Join. If there were
        any used, then wrap the whole operation in a Projection with
        the remaining attributes.
        * If all the attributes are used in the Join, do nothing
        * Try to use the same approach for Product
        * Test if it's possible to fully distribute projections over
          joins rather than splitting it up like this.
    * Restriction should follow Projection
      * Restriction optimizations:
        * "attr = ? AND attr = ?", when the value is different -> False
        * "attr = ? AND NOT(attr = ?)", when the value is the same -> False
        * "attr > ? OR attr > ?" -> "attr > ?", with the least restrictive value
          * Do the same for >=, <, <=
        * "attr > ? AND attr > ?" -> "attr > ?", with the most restrictive value
          * Do the same for >=, <, <=
        * Constant folding, eg:
          "attr1 > attr2 AND attr1 = 5" -> "5 > attr2 AND attr1 = 5"
      * Figure out how to reorganize the Restriction predicates so that all
        similar operations are closer together to allow more efficient
        optimizations. This would allow optimizations of stuff like this:

          "attr1 = ? OR attr2 = ? OR attr1 = ?"

        Into:

          "attr1 IN(..) OR attr2 = ?"

      * Inclusion with a single value can be transformed into an
        Equality test.

* A Union of relations with the same base, header, and restrictions should
  try to combine into a single relation with the restrictions using OR.

* An Intersection of relations with the same base, header, and restrictions
  should try to combine into a single relation with the restrictions using
  AND.

* A Difference of relations with the same base and restrictions should
  try to combine into a single relation with the restrictions using NOT.

* Join Optimizations
  * When a Join contains a Join, and the size of the base relations is
    known, join the smallest with the largest, and then join that result
    with the remaining relation.
  * Make sure the smallest relation (with a known size) is always the
    right-most operation.

* Allow Inclusion match to accept a Relation
  * Ensure that Inclusion can have the left/right be an Array of
    Attributes.
  * Consider transforming the value provided to an Inclusion into
    a Relation.

* Update Attributes so that constraints are modelled using predicates,
  so that when "join-ability" is tested, the predicates can just be
  compared for equality.
  * Create an object that can wrap a predicate, and if it fails it will
    set the object's error state, and then propagate the status to the
    caller. This will allow a "complex" predicate to set the errors
    on tuples, while still allowing all the same objects to be used.

* Add Relation#antijoin

* Add Relation#nest and Relation#unnest
