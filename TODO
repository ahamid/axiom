* Add a class to represent an Empty Relation.
  * Restriction, Intersection, Order, Limit, Offset can use this class to
    factor themselves out and return the Empty relation, since they cannot
    return anything other than an Empty relation.
  * Join and Product can use this class to return an empty
    relation with the unioned headers.

* Add #optimize method to each Relation subclass
  * Restriction should check to see if it contains another restriction,
    and union (and) the predicates together.
  * Projection should factor itself out if the projection is the same
    as the relation's header (with the order the same for now, since we
    sometimes use projection to reorder Tuple internals for comparison,
    which in itself will soon no longer be necessary)
  * Product with a Relation containing an empty Header should just
    return the other Relation.
  * If two relations have the same restrictions, order, limit, offset,
    header and base, then Union#optimize and Intersection#optimize should
    just return one of them.
  * If two relations have the same restrictions, order, limit, offset,
    header and base, then Difference#optimize should return an empty
    Relation.
  * See if "attr = ? OR attr = ?" can be optimized to "attr IN(..)"

* Move common methods from Predicate, Proposition and Connective up to
  a base module
  * Any cases where a method should be defined to match the
    interface (eg. invert) should be defined here too.

* In Predicate, Proposition and Connective #==, make sure that it
  works by comparing equivalent operations.  eg :id >= 1 is the
  same as not(id < 1), and should return true

* Instead of True.new and False.new, just use the constants in the code
  * Make sure that all the instance methods are changed to be class methods

* Refactor common code from Offset and Limit
  - Use Flay to identify duplicate code and refactor

* Add Relation#antijoin

* Add Relation#nest and Relation#unnest
