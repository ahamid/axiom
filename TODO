* Add #optimize method to each Relation subclass
  * If two relations have the same restrictions, order, limit, offset,
    header and base, then Union#optimize and Intersection#optimize should
    just return one of them.
  * If two relations have the same restrictions, order, limit, offset,
    header and base, then Difference#optimize should return an empty
    Relation.
  * A Limit that contains a Limit, should return a Limit object
    using the smallest limit of the two.
  * An Offset that contains an Offset should return an Offset object
    that adds the offsets together.
  * An Order that contains an Order should return the outer-most
    Order.
  * Restriction optimizations:
    * When the value is the wrong type -> False
    * "attr = ? OR attr = ?", when the value is the same -> "attr = ?"
    * "attr = ? OR attr = ?", when the value is different -> "attr IN(..)"
    * "attr = ? AND attr = ?", when the value is the same -> "attr = ?".
    * "attr = ? AND attr = ?", when the value is different -> False
    * "attr = ? AND NOT(attr = ?)", when the value is the same -> False
    * "attr > ? OR attr > ?" -> "attr > ?", with the least restrictive value
      * Do the same for >=, <, <=
    * "attr > ? AND attr > ?" -> "attr > ?", with the most restrictive value
      * Do the same for >=, <, <=
  * Figure out how to reorganize the Restriction predicates so that all
    similar operations are closer together to allow more efficient
    optimizations.  This would allow optimizations of stuff like this:

      "attr1 = ? OR attr2 = ? OR attr1 = ?"

    Into:

      "attr1 IN(..) OR attr2 = ?"

* In Predicate, Proposition and Connective #==, make sure that it
  works by comparing equivalent operations.  eg :id >= 1 is the
  same as not(id < 1), and should return true

* Instead of True.new and False.new, just use the constants in the code
  * Make sure that all the instance methods are changed to be class methods

* Use Flay to identify duplicate code and refactor

* Add Relation#antijoin

* Add Relation#nest and Relation#unnest
