* Restriction predicates should be visible to all parent relations
  because they form the base constraints all tuples must match in
  order to be included/inserted in the Relation.

* Add further optimizations:
  * If two relations have the same restrictions, order, limit, offset,
    header and base, then Union#optimize and Intersection#optimize should
    just return one of them.
  * If two relations have the same restrictions, order, limit, offset,
    header and base, then Difference#optimize should return an empty
    Relation.
  * Restriction optimizations:
    * When the value is the wrong type -> False
    * "attr = ? OR attr = ?", when the value is the same -> "attr = ?"
    * "attr = ? OR attr = ?", when the value is different -> "attr IN(..)"
    * "attr = ? AND attr = ?", when the value is the same -> "attr = ?".
    * "attr = ? AND attr = ?", when the value is different -> False
    * "attr = ? AND NOT(attr = ?)", when the value is the same -> False
    * "attr > ? OR attr > ?" -> "attr > ?", with the least restrictive value
      * Do the same for >=, <, <=
    * "attr > ? AND attr > ?" -> "attr > ?", with the most restrictive value
      * Do the same for >=, <, <=
  * Figure out how to reorganize the Restriction predicates so that all
    similar operations are closer together to allow more efficient
    optimizations.  This would allow optimizations of stuff like this:

      "attr1 = ? OR attr2 = ? OR attr1 = ?"

    Into:

      "attr1 IN(..) OR attr2 = ?"

* In Predicate, Proposition and Connective #==, make sure that it
  works by comparing equivalent operations.  eg id >= 1 is the
  same as not(id < 1), and should return when compared.

* Update True and False propositions to be singleton objects.

* Use Flay to identify duplicate code and refactor

* Add Relation#antijoin

* Add Relation#nest and Relation#unnest
