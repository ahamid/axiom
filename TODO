* Add benchmarks for memory usage of each Relation operation

* Update specs to make sure the ruby version of an operation is
  tested against the output of the operation to ensure the same
  output.  It would not make sense to benchmark against something
  that produces different results.

* Add a Reverse operation
  * Update it's #each block to simply use #reverse_each
  * Make sure it still reverses the directions though.

* Benchmark using sort_by instead of sort in the current ordering
  system.
  * see if wrapping the objects in a "sort" object is
    helpful too, since we can have something sort in reverse order
    and still use sort_by.

* Add #optimize method to each Relation subclass
  * Relation#optimize should just return self
  * See if "attr = ? OR attr = ?" can be optimized to "attr IN(..)"
  * If an OR branch always returns true, then the whole operation
    returns true, so return an object that represents a true match.
  * If the Restriction ends up containing only a single "true"
    object, then it should factor itself out since it can match
    everything.
  * For Equality, if left and right are constants, evaluate the predicate
    and return the true/false value.
  * For Equality, if left and right are the same attribute, return true
  * After optimizing a relation, set @optimized to whatever the return
    value is, and use @optimized ||= in #optimize to prevent duplicate
    effort.
  * In the optimized relation, use "relation.optimized = self" to prevent
    an already optimized relation from performing any redundant
    optimizations.
  * Should optimize the "contained" Relation objects first, and then
    compare them:

      def optimize
        relation = relation.optimize
        case relation
          when Join
            # ...
        end
      end

* Refactor common code from Offset and Limit
  - Use Flay to identify duplicate code and refactor

* Look at optimizing the Tuple as a Struct

* Add Relation#antijoin

* Add Relation#nest and Relation#unnest
