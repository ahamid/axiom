* Extract optimization into Optimizer class
  * Make sure it can be inherited and optimization overridden on a
    per-operation basis.
  * Think about the design. Will it be some sort of Factory that
    returns an object that knows how to optimize instances of a
    specific class? Will it be a map? Will different optimizers be
    needed for each adapter (YES)? Will an optimizer alter their
    approach over time? Will it take into account cases where the
    data is already known, to alter other queries (eg. if a join between
    in-memory and an RDBMS, use the in-memory values in an IN() clause)
  * Consider what it would take to expose the Optimizer to the end user
    who wants to control how optimization is performed for their
    adapter and/or add something into the chain that will take
    precedence over both the per-adapter optimizer, and the base
    optimizer. Even just making it so that the Factory object is
    returned from a method that can be easily overridden might make
    it much nicer for the end user.

* Allow materialized relations to work with #reverse, #limit, #offset
  if they have directions (this can happen when optimizing an ordered,
  materialized relation). If they are not ordered, then #order should
  be used before #reverse, #limit, #offet, etc can be used with them.

* Update memoization to take into account the arguments passed into
  the method. It should memoize differently for different
  methods. Perhaps it could have a special case for methods
  with a 0-arity vs n-arity methods, but it needs to handle cases
  like with #hash that accept no args, and #optimize that accepts
  1 arg.

* Allow two relations to be joined even if they have identical headers.
  * Update the Join optimizer so that it transforms into an Intersection
    when the headers are identical.
  * This will allow the query to be constructed with an Intersection,
    and the MySQL optimizer will be able to transform it into a Join
    without raising an exception.

* Remove Order, Reverse, Limit and Offset from the Relation inheritance chain
  * Instead make it so they are proxy classes that wrap Relations, but
    proxy method calls to the Relation methods, and then wrap the return
    value (assuming it's a Relation) in a copy of itself.
  * Also this will allow knowledge of #directions to be removed from
    all the Relation classes. Only the Ranking classes will need to know
    about directions.
  * We can also do things like optimize away an Order that is not
    wrapped by a Limit/Offset if it is wrapped in Join or Set relation.
    We can do this because joining sorted relations results in
    an undefined sort order depending on the algorithm used to join
    the tuples. The correct approach to get unambiguous results is to
    wrap the Join in an Order.
  * The Reverse class will probably not be needed either. All we need is
    for the #reverse method to create a new Order with the directions
    reversed.

* Add aliases for some common operations in Method classes, eg:
  * Predicates:
    * Alias #== to #eq (may break alot)
    * Alias #!= to #ne (in 1.9 only)
    * Alias #>= to #gte
    * Alias #> to #gt
    * Alias #<= to #lte
    * Alias #< to #lt
    * Alias #=~ to #match
  * Direction:
    * Alias #@+ to #asc
    * Alias #@- to #desc

* Use flay to identify duplicate code and refactor

* Add further optimizations:
  * Operation Order:
    * Projection should follow Rename
      * When a Projection contains a Restriction, wrap the Projection
        in the Restriction, projecting away any attributes not used in
        the restriction. If there are any remaining attributes, then
        wrap the operation in a Projection removing those attributes.
        * If all attributes are being used in the Restriction do nothing
      * When a Projection contains a Join, wrap the Join with a Projection
        of all the headers, minus those used in the Join. If there were
        any used, then wrap the whole operation in a Projection with
        the remaining attributes.
        * If all the attributes are used in the Join, do nothing
        * Try to use the same approach for Product
        * Test if it's possible to fully distribute projections over
          joins rather than splitting it up like this.
    * Restriction should follow Projection
      * Restriction optimizations:
        * "attr > ? OR attr > ?" -> "attr > ?", with the least restrictive value
          * Do the same for >=, <, <=
        * "attr > ? AND attr > ?" -> "attr > ?", with the most restrictive value
          * Do the same for >=, <, <=
        * "attr > 5 OR attr == 5" -> "attr >= 5"
        * "attr < 5 OR attr == 5" -> "attr <= 5"
        * "attr" = "string" AND "attr" =~ /string/ -> "attr" = "string"
          * If the regexp matches the constant, then it should be
            optimized down to a constant match. If it does not match
            then it should be optimized to False.
        * Constant folding, eg:
          "attr1 > attr2 AND attr1 = 5" -> "5 > attr2 AND attr1 = 5"
          * This will probably only work across Conjunctions.
        * "attr > 5 AND attr = 6" -> "attr = 6", because attr must be
          equal to 6. this will probably be related to constant folding;
          the first expression will become 6 > 5, which evaluates to
          True, then the expression is True AND attr = 6, which simplifies
          down to attr = 6.
        * "attr < 5 AND attr = 6" -> "False", because attr must be equal to
          6, and 6 < 5 evaluates to False.  False AND attr = 6 simplifies
          down to False.
      * Figure out how to reorganize the Restriction predicates so that all
        similar operations are closer together to allow more efficient
        optimizations. This would allow optimizations of stuff like this:

          "attr1 = ? OR attr2 = ? OR attr1 = ?"

        Into:

          "attr1 IN(..) OR attr2 = ?"
    * Rename should distribute over Join, Product and Set operations
      * The goal should be to push Rename as close to the base tables
        as possible so that the names of attribute will be consistent
        throughout the whole tree.

* A Union of relations with the same base, header, and restrictions should
  try to combine into a single relation with the restrictions using OR.

* An Intersection of relations with the same base, header, and restrictions
  should try to combine into a single relation with the restrictions using
  AND.

* A Difference of relations with the same base and restrictions should
  try to combine into a single relation with the restrictions using NOT.

* Join Optimizations
  * When a Join contains a Join, and the size of the base relations is
    known, join the smallest with the largest, and then join that result
    with the remaining relation.
  * Make sure the smallest relation (with a known size) is always the
    right-most operation.

* Allow Inclusion match to accept a Relation
  * Ensure that Inclusion can have the left/right be an Array of
    Attributes.
  * Consider transforming the value provided to an Inclusion into
    a Relation.

* Update Attributes so that constraints are modelled using predicates,
  so that when "join-ability" is tested, the predicates can just be
  compared for equality.
  * Create an object that can wrap a predicate, and if it fails it will
    set the object's error state, and then propagate the status to the
    caller. This will allow a "complex" predicate to set the errors
    on tuples, while still allowing all the same objects to be used.

* Add Relation#antijoin

* Add Relation#nest and Relation#unnest
