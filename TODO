* Figure out how to delegate #directions to subordinate Relations cleanly
  * Add Relation#last

* Add benchmarks for each Relation operation
  * Will allow git bisect to gather results for each iteration, and
    plot performance over time
  * Make sure the memory usage for each method is measured, as well
    as object allocation, and GC.
  * Make sure they can be run with each system rvm supports
  * Output the results in a machine readable format
    * Output the Ruby version/patch number with each result
    * Output the Engine name, which is currently named just "naive",
      referring to the in-memory naive processing approach I am
      using now.
      * Measurements will always be taken using every available engine.
  * Look at memory and speed profiling tools

* Look at optimizing the Tuple as a Struct

* Add #optimize method to each Relation subclass
  * Relation#optimize should just return self
  * See if "attr = ? OR attr = ?" can be optimized to "attr IN(..)"
  * If an OR branch always returns true, then the whole operation
    returns true, so return an object that represents a true match.
  * If the Restriction ends up containing only a single "true"
    object, then it should factor itself out since it can match
    everything.
  * For Equality, if left and right are constants, evaluate the predicate
    and return the true/false value.
  * For Equality, if left and right are the same attribute, return true
  * After optimizing a relation, set @optimized to whatever the return
    value is, and use @optimized ||= in #optimize to prevent duplicate
    effort.
  * In the optimized relation, use "relation.optimized = self" to prevent
    an already optimized relation from performing any redundant
    optimizations.
  * Should optimize the "contained" Relation objects first, and then
    compare them:

      def optimize
        relation = relation.optimize
        case relation
          when Join
            # ...
        end
      end

* Refactor common code from Offset and Limit

* Add a way to know if a Relation contains a body that is ordered
  * this should be something a "container" Relation can delegate to
    it's "contained" Relations

* Add Relation#nest and Relation#unnest

* Consider factoring out Body subclasses and using Enumerator objects
  to encapsulate the #each iteration logic.  The end result from the
  user's POV will be the same (efficient, chained enumerating), but
  internally it could also increase complexity.
