* Add return types to Function objects
  * Update Evaluator::Context to infer the type from the function if
    possible, only defaulting to Attribute::Object if the type is unknown.

* Need a way to specify if a function result allows nil or not
  * In the normal case of summarize, the value will not be nil if the
    summarize_by is a subset of the operand. However, if it is another
    relation, some functions could return nil.

* Handle case where value is nil, but being sorted on
  * Will need to figure out a way to sort nil (before all results or after)

* Remove Order, Reverse, Limit and Offset from the Relation inheritance chain
  * Instead make it so they are proxy classes that wrap Relations, but
    proxy method calls to the Relation methods, and then wrap the return
    value (assuming it's a Relation) in a copy of itself.
  * Also this will allow knowledge of #directions to be removed from
    all the Relation classes. Only the Ranking classes will need to know
    about directions.
  * We can also do things like optimize away an Order that is not
    wrapped by a Limit/Offset if it is wrapped in Join or Set relation.
    We can do this because joining sorted relations results in
    an undefined sort order depending on the algorithm used to join
    the tuples. The correct approach to get unambiguous results is to
    wrap the Join in an Order.
  * The Reverse class will probably not be needed either. All we need is
    for the #reverse method to create a new Order with the directions
    reversed.
  * Remove the knowledge of directions from materialized relations
    and instead wrap materialized relations in the Order object
    if any.

* Allow Inclusion match to accept a Relation
  * Ensure that Inclusion can have the left/right be an Array of
    Attributes.
  * Consider transforming the value provided to an Inclusion into
    a Relation.

* Update Attributes so that constraints are modelled using predicates,
  so that when "join-ability" is tested, the predicates can just be
  compared for equality.
  * Create an object that can wrap a predicate, and if it fails it will
    set the object's error state, and then propagate the status to the
    caller. This will allow a "complex" predicate to set the errors
    on tuples, while still allowing all the same objects to be used.

* Add Relation#antijoin

* Add Relation#nest and Relation#unnest

* Add aliases for some common operations in Method classes, eg:
  * Predicates:
    * Alias #== to #eq (may break alot)
    * Alias #!= to #ne (in 1.9 only)
    * Alias #>= to #gte
    * Alias #> to #gt
    * Alias #<= to #lte
    * Alias #< to #lt
    * Alias #=~ to #match
  * Direction:
    * Alias #@+ to #asc
    * Alias #@- to #desc

* Update memoization to take into account the arguments passed into
  the method. It should memoize differently for different
  methods. Perhaps it could have a special case for methods
  with a 0-arity vs n-arity methods, but it needs to handle cases
  like with #hash that accept no args, and #optimize that accepts
  1 arg.

* Allow attribute/function expressions to exist within the enumerable part
  of the Inclusion and Exclusion operations
  * The #call method should propagate the Tuple down to each callable entry
    in the Enumerable.
